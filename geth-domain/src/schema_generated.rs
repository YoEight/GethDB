// automatically generated by the FlatBuffers compiler, do not modify


// @generated

use core::mem;
use core::cmp::Ordering;

extern crate flatbuffers;
use self::flatbuffers::{EndianScalar, Follow};

#[allow(unused_imports, dead_code)]
pub mod geth {

  use core::mem;
  use core::cmp::Ordering;

  extern crate flatbuffers;
  use self::flatbuffers::{EndianScalar, Follow};

#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MIN_STREAM_EXPECTATION: u8 = 0;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MAX_STREAM_EXPECTATION: u8 = 3;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_STREAM_EXPECTATION: [StreamExpectation; 4] = [
  StreamExpectation::NONE,
  StreamExpectation::ExpectExists,
  StreamExpectation::ExpectEmpty,
  StreamExpectation::ExpectRevision,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct StreamExpectation(pub u8);
#[allow(non_upper_case_globals)]
impl StreamExpectation {
  pub const NONE: Self = Self(0);
  pub const ExpectExists: Self = Self(1);
  pub const ExpectEmpty: Self = Self(2);
  pub const ExpectRevision: Self = Self(3);

  pub const ENUM_MIN: u8 = 0;
  pub const ENUM_MAX: u8 = 3;
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::NONE,
    Self::ExpectExists,
    Self::ExpectEmpty,
    Self::ExpectRevision,
  ];
  /// Returns the variant's name or "" if unknown.
  pub fn variant_name(self) -> Option<&'static str> {
    match self {
      Self::NONE => Some("NONE"),
      Self::ExpectExists => Some("ExpectExists"),
      Self::ExpectEmpty => Some("ExpectEmpty"),
      Self::ExpectRevision => Some("ExpectRevision"),
      _ => None,
    }
  }
}
impl core::fmt::Debug for StreamExpectation {
  fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
    if let Some(name) = self.variant_name() {
      f.write_str(name)
    } else {
      f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
    }
  }
}
impl<'a> flatbuffers::Follow<'a> for StreamExpectation {
  type Inner = Self;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    let b = flatbuffers::read_scalar_at::<u8>(buf, loc);
    Self(b)
  }
}

impl flatbuffers::Push for StreamExpectation {
    type Output = StreamExpectation;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        flatbuffers::emplace_scalar::<u8>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for StreamExpectation {
  type Scalar = u8;
  #[inline]
  fn to_little_endian(self) -> u8 {
    self.0.to_le()
  }
  #[inline]
  #[allow(clippy::wrong_self_convention)]
  fn from_little_endian(v: u8) -> Self {
    let b = u8::from_le(v);
    Self(b)
  }
}

impl<'a> flatbuffers::Verifiable for StreamExpectation {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    u8::run_verifier(v, pos)
  }
}

impl flatbuffers::SimpleToVerifyInSlice for StreamExpectation {}
pub struct StreamExpectationUnionTableOffset {}

#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MIN_COMMANDS: u8 = 0;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MAX_COMMANDS: u8 = 2;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_COMMANDS: [Commands; 3] = [
  Commands::NONE,
  Commands::AppendStream,
  Commands::DeleteStream,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct Commands(pub u8);
#[allow(non_upper_case_globals)]
impl Commands {
  pub const NONE: Self = Self(0);
  pub const AppendStream: Self = Self(1);
  pub const DeleteStream: Self = Self(2);

  pub const ENUM_MIN: u8 = 0;
  pub const ENUM_MAX: u8 = 2;
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::NONE,
    Self::AppendStream,
    Self::DeleteStream,
  ];
  /// Returns the variant's name or "" if unknown.
  pub fn variant_name(self) -> Option<&'static str> {
    match self {
      Self::NONE => Some("NONE"),
      Self::AppendStream => Some("AppendStream"),
      Self::DeleteStream => Some("DeleteStream"),
      _ => None,
    }
  }
}
impl core::fmt::Debug for Commands {
  fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
    if let Some(name) = self.variant_name() {
      f.write_str(name)
    } else {
      f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
    }
  }
}
impl<'a> flatbuffers::Follow<'a> for Commands {
  type Inner = Self;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    let b = flatbuffers::read_scalar_at::<u8>(buf, loc);
    Self(b)
  }
}

impl flatbuffers::Push for Commands {
    type Output = Commands;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        flatbuffers::emplace_scalar::<u8>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for Commands {
  type Scalar = u8;
  #[inline]
  fn to_little_endian(self) -> u8 {
    self.0.to_le()
  }
  #[inline]
  #[allow(clippy::wrong_self_convention)]
  fn from_little_endian(v: u8) -> Self {
    let b = u8::from_le(v);
    Self(b)
  }
}

impl<'a> flatbuffers::Verifiable for Commands {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    u8::run_verifier(v, pos)
  }
}

impl flatbuffers::SimpleToVerifyInSlice for Commands {}
pub struct CommandsUnionTableOffset {}

pub enum ExpectExistsOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct ExpectExists<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for ExpectExists<'a> {
  type Inner = ExpectExists<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> ExpectExists<'a> {

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    ExpectExists { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    _args: &'args ExpectExistsArgs
  ) -> flatbuffers::WIPOffset<ExpectExists<'bldr>> {
    let mut builder = ExpectExistsBuilder::new(_fbb);
    builder.finish()
  }

}

impl flatbuffers::Verifiable for ExpectExists<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .finish();
    Ok(())
  }
}
pub struct ExpectExistsArgs {
}
impl<'a> Default for ExpectExistsArgs {
  #[inline]
  fn default() -> Self {
    ExpectExistsArgs {
    }
  }
}

pub struct ExpectExistsBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> ExpectExistsBuilder<'a, 'b> {
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> ExpectExistsBuilder<'a, 'b> {
    let start = _fbb.start_table();
    ExpectExistsBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<ExpectExists<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for ExpectExists<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("ExpectExists");
      ds.finish()
  }
}
pub enum ExpectEmptyOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct ExpectEmpty<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for ExpectEmpty<'a> {
  type Inner = ExpectEmpty<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> ExpectEmpty<'a> {

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    ExpectEmpty { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    _args: &'args ExpectEmptyArgs
  ) -> flatbuffers::WIPOffset<ExpectEmpty<'bldr>> {
    let mut builder = ExpectEmptyBuilder::new(_fbb);
    builder.finish()
  }

}

impl flatbuffers::Verifiable for ExpectEmpty<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .finish();
    Ok(())
  }
}
pub struct ExpectEmptyArgs {
}
impl<'a> Default for ExpectEmptyArgs {
  #[inline]
  fn default() -> Self {
    ExpectEmptyArgs {
    }
  }
}

pub struct ExpectEmptyBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> ExpectEmptyBuilder<'a, 'b> {
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> ExpectEmptyBuilder<'a, 'b> {
    let start = _fbb.start_table();
    ExpectEmptyBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<ExpectEmpty<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for ExpectEmpty<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("ExpectEmpty");
      ds.finish()
  }
}
pub enum ExpectRevisionOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct ExpectRevision<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for ExpectRevision<'a> {
  type Inner = ExpectRevision<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> ExpectRevision<'a> {
  pub const VT_REVISION: flatbuffers::VOffsetT = 4;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    ExpectRevision { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args ExpectRevisionArgs
  ) -> flatbuffers::WIPOffset<ExpectRevision<'bldr>> {
    let mut builder = ExpectRevisionBuilder::new(_fbb);
    builder.add_revision(args.revision);
    builder.finish()
  }


  #[inline]
  pub fn revision(&self) -> u64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u64>(ExpectRevision::VT_REVISION, Some(0)).unwrap()}
  }
}

impl flatbuffers::Verifiable for ExpectRevision<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<u64>("revision", Self::VT_REVISION, false)?
     .finish();
    Ok(())
  }
}
pub struct ExpectRevisionArgs {
    pub revision: u64,
}
impl<'a> Default for ExpectRevisionArgs {
  #[inline]
  fn default() -> Self {
    ExpectRevisionArgs {
      revision: 0,
    }
  }
}

pub struct ExpectRevisionBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> ExpectRevisionBuilder<'a, 'b> {
  #[inline]
  pub fn add_revision(&mut self, revision: u64) {
    self.fbb_.push_slot::<u64>(ExpectRevision::VT_REVISION, revision, 0);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> ExpectRevisionBuilder<'a, 'b> {
    let start = _fbb.start_table();
    ExpectRevisionBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<ExpectRevision<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for ExpectRevision<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("ExpectRevision");
      ds.field("revision", &self.revision());
      ds.finish()
  }
}
pub enum ProposedEventOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct ProposedEvent<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for ProposedEvent<'a> {
  type Inner = ProposedEvent<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> ProposedEvent<'a> {
  pub const VT_CLASS: flatbuffers::VOffsetT = 4;
  pub const VT_STREAM: flatbuffers::VOffsetT = 6;
  pub const VT_REVISION: flatbuffers::VOffsetT = 8;
  pub const VT_PAYLOAD: flatbuffers::VOffsetT = 10;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    ProposedEvent { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args ProposedEventArgs<'args>
  ) -> flatbuffers::WIPOffset<ProposedEvent<'bldr>> {
    let mut builder = ProposedEventBuilder::new(_fbb);
    builder.add_revision(args.revision);
    if let Some(x) = args.payload { builder.add_payload(x); }
    if let Some(x) = args.stream { builder.add_stream(x); }
    if let Some(x) = args.class { builder.add_class(x); }
    builder.finish()
  }


  #[inline]
  pub fn class(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(ProposedEvent::VT_CLASS, None)}
  }
  #[inline]
  pub fn stream(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(ProposedEvent::VT_STREAM, None)}
  }
  #[inline]
  pub fn revision(&self) -> u64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u64>(ProposedEvent::VT_REVISION, Some(0)).unwrap()}
  }
  #[inline]
  pub fn payload(&self) -> Option<flatbuffers::Vector<'a, u8>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u8>>>(ProposedEvent::VT_PAYLOAD, None)}
  }
}

impl flatbuffers::Verifiable for ProposedEvent<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("class", Self::VT_CLASS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("stream", Self::VT_STREAM, false)?
     .visit_field::<u64>("revision", Self::VT_REVISION, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u8>>>("payload", Self::VT_PAYLOAD, false)?
     .finish();
    Ok(())
  }
}
pub struct ProposedEventArgs<'a> {
    pub class: Option<flatbuffers::WIPOffset<&'a str>>,
    pub stream: Option<flatbuffers::WIPOffset<&'a str>>,
    pub revision: u64,
    pub payload: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u8>>>,
}
impl<'a> Default for ProposedEventArgs<'a> {
  #[inline]
  fn default() -> Self {
    ProposedEventArgs {
      class: None,
      stream: None,
      revision: 0,
      payload: None,
    }
  }
}

pub struct ProposedEventBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> ProposedEventBuilder<'a, 'b> {
  #[inline]
  pub fn add_class(&mut self, class: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(ProposedEvent::VT_CLASS, class);
  }
  #[inline]
  pub fn add_stream(&mut self, stream: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(ProposedEvent::VT_STREAM, stream);
  }
  #[inline]
  pub fn add_revision(&mut self, revision: u64) {
    self.fbb_.push_slot::<u64>(ProposedEvent::VT_REVISION, revision, 0);
  }
  #[inline]
  pub fn add_payload(&mut self, payload: flatbuffers::WIPOffset<flatbuffers::Vector<'b , u8>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(ProposedEvent::VT_PAYLOAD, payload);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> ProposedEventBuilder<'a, 'b> {
    let start = _fbb.start_table();
    ProposedEventBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<ProposedEvent<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for ProposedEvent<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("ProposedEvent");
      ds.field("class", &self.class());
      ds.field("stream", &self.stream());
      ds.field("revision", &self.revision());
      ds.field("payload", &self.payload());
      ds.finish()
  }
}
pub enum AppendStreamOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct AppendStream<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for AppendStream<'a> {
  type Inner = AppendStream<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> AppendStream<'a> {
  pub const VT_STREAM: flatbuffers::VOffsetT = 4;
  pub const VT_EXPECTATION_TYPE: flatbuffers::VOffsetT = 6;
  pub const VT_EXPECTATION: flatbuffers::VOffsetT = 8;
  pub const VT_EVENTS: flatbuffers::VOffsetT = 10;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    AppendStream { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args AppendStreamArgs<'args>
  ) -> flatbuffers::WIPOffset<AppendStream<'bldr>> {
    let mut builder = AppendStreamBuilder::new(_fbb);
    if let Some(x) = args.events { builder.add_events(x); }
    if let Some(x) = args.expectation { builder.add_expectation(x); }
    if let Some(x) = args.stream { builder.add_stream(x); }
    builder.add_expectation_type(args.expectation_type);
    builder.finish()
  }


  #[inline]
  pub fn stream(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(AppendStream::VT_STREAM, None)}
  }
  #[inline]
  pub fn expectation_type(&self) -> StreamExpectation {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<StreamExpectation>(AppendStream::VT_EXPECTATION_TYPE, Some(StreamExpectation::NONE)).unwrap()}
  }
  #[inline]
  pub fn expectation(&self) -> Option<flatbuffers::Table<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Table<'a>>>(AppendStream::VT_EXPECTATION, None)}
  }
  #[inline]
  pub fn events(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<ProposedEvent<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<ProposedEvent>>>>(AppendStream::VT_EVENTS, None)}
  }
  #[inline]
  #[allow(non_snake_case)]
  pub fn expectation_as_expect_exists(&self) -> Option<ExpectExists<'a>> {
    if self.expectation_type() == StreamExpectation::ExpectExists {
      self.expectation().map(|t| {
       // Safety:
       // Created from a valid Table for this object
       // Which contains a valid union in this slot
       unsafe { ExpectExists::init_from_table(t) }
     })
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn expectation_as_expect_empty(&self) -> Option<ExpectEmpty<'a>> {
    if self.expectation_type() == StreamExpectation::ExpectEmpty {
      self.expectation().map(|t| {
       // Safety:
       // Created from a valid Table for this object
       // Which contains a valid union in this slot
       unsafe { ExpectEmpty::init_from_table(t) }
     })
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn expectation_as_expect_revision(&self) -> Option<ExpectRevision<'a>> {
    if self.expectation_type() == StreamExpectation::ExpectRevision {
      self.expectation().map(|t| {
       // Safety:
       // Created from a valid Table for this object
       // Which contains a valid union in this slot
       unsafe { ExpectRevision::init_from_table(t) }
     })
    } else {
      None
    }
  }

}

impl flatbuffers::Verifiable for AppendStream<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("stream", Self::VT_STREAM, false)?
     .visit_union::<StreamExpectation, _>("expectation_type", Self::VT_EXPECTATION_TYPE, "expectation", Self::VT_EXPECTATION, false, |key, v, pos| {
        match key {
          StreamExpectation::ExpectExists => v.verify_union_variant::<flatbuffers::ForwardsUOffset<ExpectExists>>("StreamExpectation::ExpectExists", pos),
          StreamExpectation::ExpectEmpty => v.verify_union_variant::<flatbuffers::ForwardsUOffset<ExpectEmpty>>("StreamExpectation::ExpectEmpty", pos),
          StreamExpectation::ExpectRevision => v.verify_union_variant::<flatbuffers::ForwardsUOffset<ExpectRevision>>("StreamExpectation::ExpectRevision", pos),
          _ => Ok(()),
        }
     })?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<ProposedEvent>>>>("events", Self::VT_EVENTS, false)?
     .finish();
    Ok(())
  }
}
pub struct AppendStreamArgs<'a> {
    pub stream: Option<flatbuffers::WIPOffset<&'a str>>,
    pub expectation_type: StreamExpectation,
    pub expectation: Option<flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>>,
    pub events: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<ProposedEvent<'a>>>>>,
}
impl<'a> Default for AppendStreamArgs<'a> {
  #[inline]
  fn default() -> Self {
    AppendStreamArgs {
      stream: None,
      expectation_type: StreamExpectation::NONE,
      expectation: None,
      events: None,
    }
  }
}

pub struct AppendStreamBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> AppendStreamBuilder<'a, 'b> {
  #[inline]
  pub fn add_stream(&mut self, stream: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(AppendStream::VT_STREAM, stream);
  }
  #[inline]
  pub fn add_expectation_type(&mut self, expectation_type: StreamExpectation) {
    self.fbb_.push_slot::<StreamExpectation>(AppendStream::VT_EXPECTATION_TYPE, expectation_type, StreamExpectation::NONE);
  }
  #[inline]
  pub fn add_expectation(&mut self, expectation: flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(AppendStream::VT_EXPECTATION, expectation);
  }
  #[inline]
  pub fn add_events(&mut self, events: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<ProposedEvent<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(AppendStream::VT_EVENTS, events);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> AppendStreamBuilder<'a, 'b> {
    let start = _fbb.start_table();
    AppendStreamBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<AppendStream<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for AppendStream<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("AppendStream");
      ds.field("stream", &self.stream());
      ds.field("expectation_type", &self.expectation_type());
      match self.expectation_type() {
        StreamExpectation::ExpectExists => {
          if let Some(x) = self.expectation_as_expect_exists() {
            ds.field("expectation", &x)
          } else {
            ds.field("expectation", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        StreamExpectation::ExpectEmpty => {
          if let Some(x) = self.expectation_as_expect_empty() {
            ds.field("expectation", &x)
          } else {
            ds.field("expectation", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        StreamExpectation::ExpectRevision => {
          if let Some(x) = self.expectation_as_expect_revision() {
            ds.field("expectation", &x)
          } else {
            ds.field("expectation", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        _ => {
          let x: Option<()> = None;
          ds.field("expectation", &x)
        },
      };
      ds.field("events", &self.events());
      ds.finish()
  }
}
pub enum DeleteStreamOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct DeleteStream<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for DeleteStream<'a> {
  type Inner = DeleteStream<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> DeleteStream<'a> {
  pub const VT_STREAM: flatbuffers::VOffsetT = 4;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    DeleteStream { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args DeleteStreamArgs<'args>
  ) -> flatbuffers::WIPOffset<DeleteStream<'bldr>> {
    let mut builder = DeleteStreamBuilder::new(_fbb);
    if let Some(x) = args.stream { builder.add_stream(x); }
    builder.finish()
  }


  #[inline]
  pub fn stream(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(DeleteStream::VT_STREAM, None)}
  }
}

impl flatbuffers::Verifiable for DeleteStream<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("stream", Self::VT_STREAM, false)?
     .finish();
    Ok(())
  }
}
pub struct DeleteStreamArgs<'a> {
    pub stream: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for DeleteStreamArgs<'a> {
  #[inline]
  fn default() -> Self {
    DeleteStreamArgs {
      stream: None,
    }
  }
}

pub struct DeleteStreamBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> DeleteStreamBuilder<'a, 'b> {
  #[inline]
  pub fn add_stream(&mut self, stream: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(DeleteStream::VT_STREAM, stream);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> DeleteStreamBuilder<'a, 'b> {
    let start = _fbb.start_table();
    DeleteStreamBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<DeleteStream<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for DeleteStream<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("DeleteStream");
      ds.field("stream", &self.stream());
      ds.finish()
  }
}
pub enum CommandOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct Command<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Command<'a> {
  type Inner = Command<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> Command<'a> {
  pub const VT_COMMAND_TYPE: flatbuffers::VOffsetT = 4;
  pub const VT_COMMAND: flatbuffers::VOffsetT = 6;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    Command { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args CommandArgs
  ) -> flatbuffers::WIPOffset<Command<'bldr>> {
    let mut builder = CommandBuilder::new(_fbb);
    if let Some(x) = args.command { builder.add_command(x); }
    builder.add_command_type(args.command_type);
    builder.finish()
  }


  #[inline]
  pub fn command_type(&self) -> Commands {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<Commands>(Command::VT_COMMAND_TYPE, Some(Commands::NONE)).unwrap()}
  }
  #[inline]
  pub fn command(&self) -> Option<flatbuffers::Table<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Table<'a>>>(Command::VT_COMMAND, None)}
  }
  #[inline]
  #[allow(non_snake_case)]
  pub fn command_as_append_stream(&self) -> Option<AppendStream<'a>> {
    if self.command_type() == Commands::AppendStream {
      self.command().map(|t| {
       // Safety:
       // Created from a valid Table for this object
       // Which contains a valid union in this slot
       unsafe { AppendStream::init_from_table(t) }
     })
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn command_as_delete_stream(&self) -> Option<DeleteStream<'a>> {
    if self.command_type() == Commands::DeleteStream {
      self.command().map(|t| {
       // Safety:
       // Created from a valid Table for this object
       // Which contains a valid union in this slot
       unsafe { DeleteStream::init_from_table(t) }
     })
    } else {
      None
    }
  }

}

impl flatbuffers::Verifiable for Command<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_union::<Commands, _>("command_type", Self::VT_COMMAND_TYPE, "command", Self::VT_COMMAND, false, |key, v, pos| {
        match key {
          Commands::AppendStream => v.verify_union_variant::<flatbuffers::ForwardsUOffset<AppendStream>>("Commands::AppendStream", pos),
          Commands::DeleteStream => v.verify_union_variant::<flatbuffers::ForwardsUOffset<DeleteStream>>("Commands::DeleteStream", pos),
          _ => Ok(()),
        }
     })?
     .finish();
    Ok(())
  }
}
pub struct CommandArgs {
    pub command_type: Commands,
    pub command: Option<flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>>,
}
impl<'a> Default for CommandArgs {
  #[inline]
  fn default() -> Self {
    CommandArgs {
      command_type: Commands::NONE,
      command: None,
    }
  }
}

pub struct CommandBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> CommandBuilder<'a, 'b> {
  #[inline]
  pub fn add_command_type(&mut self, command_type: Commands) {
    self.fbb_.push_slot::<Commands>(Command::VT_COMMAND_TYPE, command_type, Commands::NONE);
  }
  #[inline]
  pub fn add_command(&mut self, command: flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Command::VT_COMMAND, command);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> CommandBuilder<'a, 'b> {
    let start = _fbb.start_table();
    CommandBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<Command<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for Command<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("Command");
      ds.field("command_type", &self.command_type());
      match self.command_type() {
        Commands::AppendStream => {
          if let Some(x) = self.command_as_append_stream() {
            ds.field("command", &x)
          } else {
            ds.field("command", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        Commands::DeleteStream => {
          if let Some(x) = self.command_as_delete_stream() {
            ds.field("command", &x)
          } else {
            ds.field("command", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        _ => {
          let x: Option<()> = None;
          ds.field("command", &x)
        },
      };
      ds.finish()
  }
}
#[inline]
/// Verifies that a buffer of bytes contains a `Command`
/// and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_command_unchecked`.
pub fn root_as_command(buf: &[u8]) -> Result<Command, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::root::<Command>(buf)
}
#[inline]
/// Verifies that a buffer of bytes contains a size prefixed
/// `Command` and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `size_prefixed_root_as_command_unchecked`.
pub fn size_prefixed_root_as_command(buf: &[u8]) -> Result<Command, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::size_prefixed_root::<Command>(buf)
}
#[inline]
/// Verifies, with the given options, that a buffer of bytes
/// contains a `Command` and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_command_unchecked`.
pub fn root_as_command_with_opts<'b, 'o>(
  opts: &'o flatbuffers::VerifierOptions,
  buf: &'b [u8],
) -> Result<Command<'b>, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::root_with_opts::<Command<'b>>(opts, buf)
}
#[inline]
/// Verifies, with the given verifier options, that a buffer of
/// bytes contains a size prefixed `Command` and returns
/// it. Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_command_unchecked`.
pub fn size_prefixed_root_as_command_with_opts<'b, 'o>(
  opts: &'o flatbuffers::VerifierOptions,
  buf: &'b [u8],
) -> Result<Command<'b>, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::size_prefixed_root_with_opts::<Command<'b>>(opts, buf)
}
#[inline]
/// Assumes, without verification, that a buffer of bytes contains a Command and returns it.
/// # Safety
/// Callers must trust the given bytes do indeed contain a valid `Command`.
pub unsafe fn root_as_command_unchecked(buf: &[u8]) -> Command {
  flatbuffers::root_unchecked::<Command>(buf)
}
#[inline]
/// Assumes, without verification, that a buffer of bytes contains a size prefixed Command and returns it.
/// # Safety
/// Callers must trust the given bytes do indeed contain a valid size prefixed `Command`.
pub unsafe fn size_prefixed_root_as_command_unchecked(buf: &[u8]) -> Command {
  flatbuffers::size_prefixed_root_unchecked::<Command>(buf)
}
#[inline]
pub fn finish_command_buffer<'a, 'b>(
    fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
    root: flatbuffers::WIPOffset<Command<'a>>) {
  fbb.finish(root, None);
}

#[inline]
pub fn finish_size_prefixed_command_buffer<'a, 'b>(fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>, root: flatbuffers::WIPOffset<Command<'a>>) {
  fbb.finish_size_prefixed(root, None);
}
}  // pub mod Geth

